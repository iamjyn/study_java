package com.study._30_NestedClass.nested_inner;

public class Main {
    public static void main(String[] args) {
        // 바깥 먼저 생성 -> 내부 생성
        // Question.Choice choice = new Question.Choice("선택지", 1); 불가능

        Question q1 = new Question(1, "내부 클래스의 특징으로 올바른 것은?");

        // 권장사항이 아니다.
        // Question.Choice choice = q1.new Choice(1, "선택예시1");

        q1.addChoice(0, "static 키워드가 필요하다.");
        q1.addChoice(1, "바깥 클래스의 인스턴스에 소속된다.");
        q1.addChoice(2, "독립적으로 존재할 수 있다.");
        q1.addChoice(3, "바깥 클래스 필드에 접근할 수 없다.");

        q1.printQuestion();

        /*
        주의사항
        1. 연관되어진 클래스가 기술적으로 연관된 것보다 논리적으로 연관되었는지 확인
        2. 내부클래스를 정의할 때 정적 내부클래스를 권장하는지 설명하세요
        -> 메모리 누수 때문

        선택지 인스턴스는 반드시 문제 인스턴스 안에서 생성될 수 있다.
        -> 선택지는 항상 문제 인스턴스의 주소를 참조하고 있는 상태

        문제 인스턴스가 더이상 사용되지 않는 상황이 올 때,
        GC(가비지콜렉터)에 의해 메모리가 수거되어야 하는 상황이어야 한다.
        하지만, 선택지 인스턴스가 외부로 노출돼서(주소) 다른 객체가 사용한다면,
        선택지가 문제를 참조하고 있으므로, GC가 수거하지 않는다.

        따라서, 정적 중첩 클래스를 사용하는게 권장 된다.

        혹은, 아래와 같은 방법으로 안전하게 설계해야 한다.
        1. 내부 클래스 생성자를 private로 만들어서 외부 생성을 제한
        2. 내부 클래스는 바깥 클래스의 메서드로만 생성하고,
           생성된 내부 객체는 외부에 노출되지 않게 private 필드에만 저장한다.
        -> 내부 클래스 객체의 주소를 숨겨라!
        */

    }
}
